#import time

from meerkat.base import time, _struct_time, Base


class TimePiece(Base):
    """Formatting methods for creating strftime compliant timestamps

    Data sources: 'local', 'rtc', 'gps', 'external'
    Data kinds: 'std_time', std_time_ms', 'iso_time', 'file_time', 'gps_location', 'external'
    """
    def __init__(self, source='local', kind='std_time_ms', time_zone=None):

        super().__init__()

        self._import_error = []
        self._struct_time = _struct_time

        self.kinds_available = {'std_time':     '%Y-%m-%d %H:%M:%S',
                                'std_time_ms':  '%Y-%m-%d %H:%M:%S.%f',
                                'iso_time':     '%Y-%m-%dT%H:%M:%S.%f%z',
                                'file_time':    '%Y_%m_%d_%H_%M_%S',
                                'gps_location': 'NMEA RMC message format',
                                'external':     'external source'
                                }
        self.source = None
        self.set_source(source)
        
        self.kind = kind
        self.time_format = None
        #self.set_format(kind)

        # optional timezone
        self._tz = None
        self.tz  = time_zone

        # external hardware time sources, must be set after initialization
        self.rtc = None
        self.gps = None

        # external time string, generated by another instance or external source
        self._external_time = None

    @property
    def tz(self):
        return self._tz

    @tz.setter
    def tz(self, time_zone):
        if time_zone is None:
            self._tz = ''
        else: self._tz = time_zone

    def set_source(self, source):
        """Override default time source
        Must be one of the following: 'local', 'rtc', 'gps', 'external'
        """
        assert source in ['local', 'rtc', 'gps', 'external'], f'Source `{source}` not supported'
        self.source = source

    def set_kind(self, kind):
        """Override default time output format. Must be one of the
        the following (from self.formats_available):
            'std_time',
            'std_time_ms',
            'iso_time',
            'file_time',
            'gps_location',
            'external'   # time_format from external timepiece instance
        """
        assert kind in self.kinds_available.keys(), f'Kind `{kind}` not supported'
        self.kind = kind
        self.time_format = self.kinds_available[kind]

    def set_time(self, time_str):
        """Set the returned string formatted time manually. Used for shared
        timestamps. To be useful in post-collection analysis, set the format
        name with self.set_format to the same format as the input argument.

        Parameters
        ----------
        time_str : str, in one of the formats generated by this class, as
            listed by self.formats_available
        """
        self._external_time = time_str

    def get_time(self):
        """Get the time in a specific format.  For creating a reproducible
        format citation based on the attributes of the TimeFormats class.

        Returns
        -------
        str, formatted current time based on input argument
        """
        if self.source == 'external':
            return self._eternal_time
        if (self.source == 'gps') & (self.kind == 'gps_location'):
            return self.gps_location()
        if self.source == 'local':
            t = self._struct_time()
        if self.source == 'rtc':
            t = self.rtc_time()
        if self.source == 'gps':
            t = self.gps_time()

        _formats = {'std_time':     '{:02d}-{:02d}-{:02d} {:02d}:{:02d}:{:02d}',
                    'std_time_ms':  '{:02d}-{:02d}-{:02d} {:02d}:{:02d}:{:02d}.{:06}',
                    'iso_time':     '{:02d}-{:02d}-{:02d}T{:02d}:{:02d}:{:02d}.{:06}' + self.tz,
                    'file_time':    '{:02d}_{:02d}_{:02d}_{:02d}_{:02d}_{:02d}',
                    }
        str_format = _formats[self.kind]
        return str_format.format(*t)  # format doesn't like tuples, needs args

    def rtc_time(self):
        """Get time from the DS3221 RTC

        Parameters
        ----------
        bus_n : int, I2C bus number to access the RTC on
        bus_addr : int, I2C bus address the RTC is at on the bus

        Returns
        -------
        RTC time in std_time format
        """
        t = self.rtc.get_time()
        return t[0], t[1], t[2], t[3], t[4], t[5], 0

    def gps_location(self):
        """Get NMEA RMC message from the PA1010D GPS

        Parameters
        ----------
        bus_n : int, I2C bus number to access the RTC on
        bus_addr : int, I2C bus address the RTC is at on the bus

        Returns
        -------
        GPS date, lat, lon and time in NMEA RMC format
        """
        nmea_sentence = self.gps.get(nmea_sentences=['RMC'])[0]
        return nmea_sentence

    def gps_time(self, timeout=120):
        """Get time from the PA1010D GPS

        Parameters
        ----------
        bus_n : int, I2C bus number to access the RTC on
        bus_addr : int, I2C bus address the RTC is at on the bus

        Returns
        -------
        RTC time in iso_time format
        """
        t0 = time.time()
        while True:
            t1 = time.time()
            try:
                nmea_sentence = self.gps_location()
                nmea_sentence = nmea_sentence.split(',')
                t = nmea_sentence[1].split('.')[0]
                t_ms = nmea_sentence[1].split('.')[1]
                t = [t[:2], t[2:4], t[4:]]
                d = nmea_sentence[9]
                d = ['20' + d[4:], d[2:4], d[:2]]
                return d[0], d[1], d[2], t[0], t[1], t[2], t_ms
            except:
                if t1 - t0 > timeout:
                    return 'gps_timeout'
                continue

    def external_time(self):
        """Return a previously set external time. Useful for synchronizing
        timestamps between data sources"""
        return self._external_time
