import time

from meerkat.base import Base, _struct_time


class TimePiece(Base):
    """Formatting methods for creating strftime compliant timestamps"""
    def __init__(self, time_source='std_time', time_zone=None):
        super().__init__()

        self._import_error = []
        self._struct_time = _struct_time

        self.formats_available = {'std_time':    '%Y-%m-%d %H:%M:%S',
                                  'std_time_ms': '%Y-%m-%d %H:%M:%S.%f',
                                  'iso_time':    '%Y-%m-%dT%H:%M:%S.%f%z',
                                  'file_time':   '%Y_%m_%d_%H_%M_%S',
                                  'rtc_time':    '%Y-%m-%d %H:%M:%S',        # same as std_time
                                  'gps_time':    '%Y-%m-%dT%H:%M:%S.%f+%z',  # same as iso_time
                                  'gps_location': 'NMEA_RMC'  # recommended minimum specific GPS/transit data message
                                 }
        #self.format    = time_source
        #self.strfmtime = self.formats_available[time_source]
        self.set_format(time_source)

        # optional timezone
        self._tz = None
        self.tz  = time_zone

        # external hardware time sources, must be set after initialization
        self.rtc = None
        self.gps = None

        # external time string, generated by another instance or external source
        self._external_time = None

    @property
    def tz(self):
        return self._tz

    @tz.setter
    def tz(self, time_zone):
        if time_zone is None:
            self._tz = ''
        else: self._tz = time_zone

    def set_format(self, time_source):
        """Override default time source and output format. Must be one of the
        the following (from self.formats_available):
            'std_time',
            'std_time_ms',
            'iso_time',
            'file_time',
            'rtc_time',  # same format as std_time, but sourced from RTC
            'gps_time',  # same format as iso_time, but sourced from GPS
            'gps_location',
            'external'   # strfmtime from external timepiece instance
        """
        self.format     = time_source
        if self.format != 'external':
            self.strfmtime = self.formats_available[time_source]

    def set_time(self, time_str):
        """Set the returned string formatted time manually. Used for shared
        timestamps. To be useful in post-collection analysis, set the format
        name with self.set_format to the same format as the input argument.

        Parameters
        ----------
        time_str : str, in one of the formats generated by this class, as
            listed by self.formats_available
        """
        self._external_time = time_str

    def get_time(self):
        """Get the time in a specific format.  For creating a reproducible
        format citation based on the attributes of the TimeFormats class.

        Returns
        -------
        str, formatted current time based on input argument
        """
        _formats = {'std_time': self.std_time, 'std_time_ms': self.std_time_ms,
                    'iso_time': self.iso_time, 'file_time':   self.file_time,
                    'rtc_time': self.rtc_time, 'gps_time':    self.gps_time,
                    'gps_location': self.gps_location, 'external': self.external_time}
        _method = _formats[self.format]
        return _method()

    def std_time(self, str_format='{:02d}-{:02d}-{:02d} {:02d}:{:02d}:{:02d}'):
        # TODO: remove in favor of ISO time
        """Get time in stardard format '%Y-%m-%d %H:%M:%S' and accurate
        to the second
        """
        t = self._struct_time()
        return str_format.format(t[0], t[1], t[2], t[3], t[4], t[5])

    def std_time_ms(self, str_format='{:02d}-{:02d}-{:02d} {:02d}:{:02d}:{:02d}.{:06}'):
        # TODO: remove in favor of ISO time
        """Get time in standard format '%Y-%m-%d %H:%M:%S.%f' and
        accurate to the microsecond
        """
        t = self._struct_time()
        return str_format.format(t[0], t[1], t[2], t[3], t[4], t[5], t[6])

    def iso_time(self):
        """Get time in ISO 8601 format '%Y-%m-%dT%H:%M:%SZ' and
        accurate to the second.  Note: assumes system clock is UTC.
        """
        str_format = '{:02d}-{:02d}-{:02d}T{:02d}:{:02d}:{:02d}.{:06}' + self.tz
        return self.std_time_ms(str_format=str_format)

    def file_time(self):
        """Get time in a format compatible with filenames,
        '%Y_%m_%d_%H_%M_%S_%f' and accurate to the second
        """
        str_format = '{:02d}_{:02d}_{:02d}_{:02d}_{:02d}_{:02d}'
        return self.std_time(str_format)

    def rtc_time(self):  #, bus_n=1, bus_addr=0x68):
        """Get time from the DS3221 RTC

        Parameters
        ----------
        bus_n : int, I2C bus number to access the RTC on
        bus_addr : int, I2C bus address the RTC is at on the bus

        Returns
        -------
        RTC time in std_time format
        """
        t = self.rtc.get_time()
        str_format='{:02d}-{:02d}-{:02d} {:02d}:{:02d}:{:02d}'
        return str_format.format(t[0], t[1], t[2], t[3], t[4], t[5])

    def gps_location(self):
        """Get NMEA RMC message from the PA1010D GPS

        Parameters
        ----------
        bus_n : int, I2C bus number to access the RTC on
        bus_addr : int, I2C bus address the RTC is at on the bus

        Returns
        -------
        GPS date, lat, lon and time in NMEA RMC format
        """
        nmea_sentence = self.gps.get(nmea_sentences=['RMC'])[0]
        return nmea_sentence

    def gps_time(self, timeout=120):
        """Get time from the PA1010D GPS

        Parameters
        ----------
        bus_n : int, I2C bus number to access the RTC on
        bus_addr : int, I2C bus address the RTC is at on the bus

        Returns
        -------
        RTC time in iso_time format
        """
        t0 = time.time()
        while True:
            try:
                nmea_sentence = self.gps_location()
                nmea_sentence = nmea_sentence.split(',')
                t = nmea_sentence[1].split('.')[0]
                t_ms = nmea_sentence[1].split('.')[1]
                t = [t[:2], t[2:4], t[4:]]
                d = nmea_sentence[9]
                d = ['20'+d[4:], d[2:4], d[:2]]
                str_format='{}-{}-{}T{}:{}:{}.{}+0:00'
                break
            except:
                if t1 - t0 > timeout:
                    return 'gps_timeout'
                continue
        return str_format.format(d[0], d[1], d[2], t[0], t[1], t[2], t_ms)

    def external_time(self):
        """Return a previously set external time. Useful for synchronizing
        timestamps between data sources"""
        return self._external_time